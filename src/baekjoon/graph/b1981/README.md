새로운 접근법: 투 포인터 (Two Pointers)
이분 탐색이 **'정답(차이값)'**을 기준으로 탐색했다면, 투 포인터는 '경로에 사용될 숫자의 범위' 자체를 직접 탐색합니다.

핵심 아이디어
배열에 있는 모든 숫자를 중복 없이 오름차순으로 정렬한 리스트 unique_nums를 준비합니다.

left와 right 두 개의 포인터를 unique_nums 리스트의 시작(인덱스 0)에 둡니다.

unique_nums[left]는 경로의 최솟값, unique_nums[right]는 경로의 최댓값을 의미합니다. 이 [최솟값, 최댓값] 범위를 "윈도우"라고 부르겠습니다.

이 윈도우를 움직여가며, 목적지까지 도달 가능한 가장 좁은(차이가 작은) 윈도우를 찾습니다.

알고리즘 동작 과정
left = 0, right = 0에서 시작합니다.

while 루프: right 포인터가 unique_nums 리스트의 끝에 도달할 때까지 반복합니다.

현재 윈도우 [unique_nums[left], unique_nums[right]]의 값들만 사용해서 (0,0)에서 (n-1,n-1)까지 bfs 탐색을 시도합니다.

경로를 찾았다면 (bfs 성공):

현재 윈도우의 차이 unique_nums[right] - unique_nums[left]는 정답 후보입니다. 현재까지 찾은 정답보다 작다면 갱신합니다.

더 좋은 답(더 작은 차이)을 찾기 위해 윈도우를 더 좁혀야 합니다. left 포인터를 한 칸 오른쪽으로 이동시켜 윈도우의 시작 값을 높여봅니다.

경로를 못 찾았다면 (bfs 실패):

현재 윈도우가 너무 좁다는 의미입니다. 더 큰 숫자를 포함해야 하므로 윈도우를 넓혀야 합니다. right 포인터를 한 칸 오른쪽으로 이동시켜 윈도우의 끝 값을 높입니다.

이 과정을 반복하면, left와 right가 움직이며 가능한 모든 유효한 숫자 범위를 효율적으로 탐색하게 되고, 그중 차이가 가장 작은 값을 찾을 수 있습니다.

# 이분 탐색과 투 포인터의 차이
## 이분 탐색 (Parametric Search) - '결정 문제'로의 변환
이분 탐색은 우리가 찾으려는 **'정답 자체(최댓값-최솟값의 차이)'**를 탐색 대상으로 삼습니다.

탐색 방식:

"정답이 k 이하일 수 있는가?" 라는 질문을 던집니다. (이것이 is_possible(k) 함수입니다.)

k를 0과 200 사이에서 이분 탐색(Jump)하며 질문을 반복합니다. (예: "차이가 100 이하일 수 있나?", "그렇다면 50 이하도 되나?" 등)

구현 구조:

외부(이분 탐색): k값을 조절하며 is_possible 함수를 호출하는 역할만 합니다.

내부(is_possible): k라는 고정된 차이값이 주어지면, 이 차이를 만족하는 경로가 있는지 처음부터 다시 탐색합니다. (for min_v in unique_nums... 루프)

실패했던 이유 (구현의 함정):
이 구조는 탐색 로직이 외부와 내부로 분리됩니다. is_possible 함수 내부에서 min_v를 순회하며 bfs를 호출하는 또 다른 탐색이 이루어지는 중첩된 탐색 구조를 가집니다. 이 때문에 두 탐색 간의 상호작용에서 저희가 겪었던 것처럼 미묘한 논리적 오류가 발생할 가능성이 상대적으로 높습니다.

## 투 포인터 (Two Pointers) - '후보 구간'의 직접 탐색
투 포인터는 '정답(차이값)'을 추측하는 대신, 정답을 만들 수 있는 '숫자의 유효한 범위 [min_v, max_v]' 자체를 직접 탐색합니다.

탐색 방식:

unique_nums 리스트 위에 left(최솟값), right(최댓값) 포인터를 놓고 시작합니다.

두 포인터가 만드는 구간 [unique_nums[left], unique_nums[right]]으로 경로 탐색(bfs)을 수행합니다.

결과에 따라 포인터를 선형적으로(한 칸씩) 움직입니다.

경로 찾기 성공: 더 좋은 답(더 작은 차이)을 찾기 위해 구간을 줄여봅니다. (left를 오른쪽으로 한 칸 이동)

경로 찾기 실패: 현재 구간이 너무 좁으므로 구간을 넓혀야 합니다. (right를 오른쪽으로 한 칸 이동)

구현 구조:

하나의 while 루프 안에서 모든 로직이 통합되어 있습니다. bfs의 결과에 따라 left나 right 포인터를 움직이는 결정이 즉시 내려집니다.

중첩된 탐색 없이, left와 right 포인터가 앞으로 나아가기만 하는 단일 탐색 구조입니다.

성공한 이유 (구현의 간결함):
로직이 분리되지 않고 하나의 흐름으로 이어지기 때문에 상태 변화를 추적하기가 더 쉽고 직관적입니다. "경로가 있으면 왼쪽을 당기고, 없으면 오른쪽을 민다"는 단순한 규칙 덕분에 구현이 간단하고 실수를 할 여지가 적었습니다.

### 핵심 차이점 요약
구분	이분 탐색 (Parametric Search)	투 포인터 (Two Pointers)
탐색 대상	**정답(차이값 k)**을 추측	**정답을 만드는 후보 구간 [min, max]**을 직접 조작
탐색 방식	정답 범위를 불연속적으로 점프하며 탐색 (log N번)	후보 구간을 선형적으로 이동하며 탐색 (슬라이딩 윈도우)
구조	외부(이분탐색)와 내부(is_possible)로 탐색 로직이 분리/중첩됨	while 루프 하나에 탐색 로직이 통합됨
장단점	구현이 복잡해질 수 있고, 미묘한 버그 발생 가능	로직이 직관적이고, 구현이 간결하여 실수가 적음

Sheets로 내보내기
결론적으로, 이 문제에서는 투 포인터 방식이 더 직접적이고 단일한 로직으로 문제를 풀기 때문에 우리가 겪었던 논리적 함정을 피하고 더 쉽게 정답에 도달할 수 있었습니다.