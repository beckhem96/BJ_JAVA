1. 문제 분석 및 핵심 아이디어
목표: 여러 목적지 후보들 중에서, 출발지 s로부터 최단 경로로 이동했을 때 반드시 g와 h 사이의 도로를 거쳐 갔을 가능성이 있는 목적지만을 모두 찾아내는 것입니다.

핵심 조건:

경로는 s에서 목적지까지의 최단 경로여야 한다.

그 최단 경로는 반드시 g-h 도로를 포함해야 한다.

이 두 조건을 만족시키려면 어떤 등식이 성립해야 할까요?
s에서 목적지 x로 가는 경로가 g-h 도로를 지난다면, 그 경로는 둘 중 하나입니다.

s → ... → g → h → ... → x

s → ... → h → g → ... → x

그리고 이 경로가 최단 경로이려면, 각 부분 경로(s에서 g, h에서 x 등) 역시 최단 경로여야 합니다. 따라서, 우리는 다음 등식을 세울 수 있습니다.

s에서 x까지의 최단 거리 == (s에서 g까지 최단 거리 + g에서 h까지 거리 + h에서 x까지 최단 거리)

또는

s에서 x까지의 최단 거리 == (s에서 h까지 최단 거리 + h에서 g까지 거리 + g에서 x까지 최단 거리)

이 등식 중 하나라도 만족하면, 목적지 x는 정답 후보가 됩니다.
이 등식을 확인하기 위해서는 s, g, h 세 지점에서 각각 다른 모든 지점까지의 최단 거리를 알아야 합니다.

2. 접근 방식 및 해결 과정
핵심 아이디어에서 보았듯이, 우리는 총 세 번의 최단 경로 탐색이 필요합니다. 음수 가중치가 없는 일반적인 최단 경로 문제이므로 다익스트라 알고리즘을 사용하는 것이 가장 효율적입니다.

1단계: 다익스트라 알고리즘 3회 실행
출발점 s 기준: s에서 모든 정점까지의 최단 거리를 계산합니다. (dist_from_s 배열)

교차로 g 기준: g에서 모든 정점까지의 최단 거리를 계산합니다. (dist_from_g 배열)

교차로 h 기준: h에서 모든 정점까지의 최단 거리를 계산합니다. (dist_from_h 배열)

2단계: 후보 목적지 판별
이제 모든 준비가 끝났습니다. 각 목적지 후보 x에 대해, 위에서 세운 등식이 성립하는지 확인합니다.

g-h 사이의 도로 길이를 cost_gh라고 합시다.

s -> g -> h -> x 경로의 최단 길이를 계산합니다: path1 = dist_from_s[g] + cost_gh + dist_from_h[x]

s -> h -> g -> x 경로의 최단 길이를 계산합니다: path2 = dist_from_s[h] + cost_gh + dist_from_g[x]

s에서 x까지의 전체 최단 거리는 dist_from_s[x] 입니다.

dist_from_s[x]가 path1 또는 path2와 같은지 확인합니다. 만약 같다면, x는 정답 후보입니다.

잠깐! 다익스트라 알고리즘이란?
목적: 가중치가 있는 그래프에서, 특정 시작 정점으로부터 다른 모든 정점까지의 최단 경로를 찾는 알고리즘입니다. (단, 간선의 가중치는 음수이면 안 됩니다.)

핵심 도구: 우선순위 큐 (Priority Queue)

동작 원리:

시작 정점만 거리가 0이고, 나머지는 무한대(INF)로 초기화합니다.

우선순위 큐에 시작 정점을 넣습니다.

큐에서 '현재까지의 거리가 가장 짧은' 정점을 꺼냅니다.

해당 정점과 연결된 이웃 정점들을 확인하며, 기존에 알려진 거리보다 더 짧은 경로를 발견하면 거리를 갱신하고 우선순위 큐에 넣습니다.

큐가 빌 때까지 반복합니다.