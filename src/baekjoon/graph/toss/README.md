아, 오늘 코딩 테스트 보시느라 정말 고생 많으셨습니다. 시험장에서 만나는 문제는 더 어렵게 느껴지기 마련이죠. 풀지 못한 문제가 마음에 남는 것은 당연합니다. 하지만 괜찮습니다. 함께 차근차근 복기해보면 다음에는 분명히 해결하실 수 있을 겁니다.

말씀해주신 문제는 전형적인 **그래프 탐색(Graph Traversal)** 문제입니다. 특정 인물(`check`의 원소)로부터 시작해서 보증된 인물(`trustedUsers`)까지 신뢰의 경로가 존재하는지를 찾는 것이 핵심입니다.

-----

### 1\. 문제 유형 분석 및 핵심 아이디어

이 문제는 'A가 B를 보증한다'는 관계를 방향성이 있는 간선 `A -> B`로 볼 수 있는 **방향 그래프(Directed Graph)** 문제입니다. 그리고 `check`에 있는 사람 `P`가 보증되었는지를 알려면, `P -> ... -> trustedUser`로 이어지는 경로가 있는지를 확인해야 합니다.

가장 직관적인 방법은 `check` 리스트의 각 사람마다 DFS나 BFS를 시작해서, `trustedUsers` 중 한 명에게 도달할 수 있는지 일일이 확인하는 것입니다. 하지만 더 효율적인 방법은 **관점을 바꾸는 것**입니다.

'확인할 사람'에서 출발하는 대신, **'보증된 사람'에서부터 시작해서 "이 사람을 보증한 사람은 누구지?"라고 신뢰의 근원을 역으로 추적**해 나가는 것입니다.

-----

### 2\. 접근 방식 및 해결 과정 (역방향 탐색)

이 문제는 다음의 명확한 3단계로 해결할 수 있습니다.

#### **1단계: 그래프 모델링 (역방향 그래프 만들기)**

'A가 B를 보증한다'는 관계는 `A -> B` 화살표로 생각할 수 있습니다. 우리가 하고 싶은 것은 '보증된 사람'으로 도달할 수 있는 모든 사람을 찾는 것이므로, 이 화살표를 반대로 거슬러 올라가야 합니다.

따라서, 우리는 '누가 이 사람을 보증하는가?'를 쉽게 찾기 위해 **간선의 방향을 뒤집은 역방향 그래프**를 만듭니다.

  * `queries`에 `[A, B]` 연결이 있다면, 이는 `A -> B`를 의미합니다.
  * 우리가 만들 역방향 그래프에는 `B -> A` 연결을 추가합니다.

#### **2단계: 보증된 모든 사람 찾기 (BFS 수행)**

이제 이 역방향 그래프를 사용해, 보증의 근원인 `trustedUsers`로부터 탐색을 시작합니다. 이 탐색을 통해 '보증의 피라미드'에 속한 모든 사람을 찾아낼 수 있습니다.

1.  **큐(Queue)를 생성**하고, 모든 `trustedUsers`를 큐에 넣습니다.
2.  어떤 사람이 보증되었는지 여부를 기록할 `isTrusted`와 같은 `boolean` 배열 또는 `Set`을 만듭니다. 큐에 넣은 `trustedUsers`들은 모두 `true`로 표시합니다.
3.  큐에서 사람을 한 명씩 꺼내, 역방향 그래프에서 그 사람을 보증하는 다음 사람들을 찾아봅니다.
4.  만약 그 다음 사람이 아직 `isTrusted`로 표시되지 않았다면, 그 사람도 보증된 사람이므로 `isTrusted`로 표시하고 큐에 추가합니다.
5.  이 과정을 큐가 빌 때까지 반복합니다.

#### **3단계: 결과 확인**

2단계가 끝나면, `isTrusted` 배열(또는 Set)에는 초기 `trustedUsers`를 포함하여, 그들을 직간접적으로 보증하는 모든 사람들의 정보가 담기게 됩니다.

이제 `check` 리스트를 순회하며 각 사람이 `isTrusted`에 포함되어 있는지 확인만 하면 됩니다. `isTrusted` 배열이나 Set에서의 조회는 매우 빠르므로, 전체 문제를 효율적으로 해결할 수 있습니다.

-----

### 마무리하며

결론적으로 이 문제는 '한 명씩 확인하기'보다 '한 번에 전체 신뢰 관계 파악하기'가 훨씬 효율적이라는 것을 보여줍니다. **그래프의 방향을 뒤집어 생각하는 역방향 탐색**은 이런 종류의 '도달 가능성' 문제에서 매우 유용하고 강력한 테크닉이니 꼭 기억해두세요.

### 방향 그래프 (Directed Graph)란?

가장 간단하게 비유하자면, 그래프는 \*\*'지도'\*\*이고 방향 그래프는 \*\*'일방통행 도로만 있는 지도'\*\*입니다.

일반적인 그래프(무방향 그래프)에서는 A와 B가 도로로 연결되어 있다면, A에서 B로도, B에서 A로도 갈 수 있습니다. 양방향 통행 도로와 같죠.

하지만 \*\*방향 그래프(Directed Graph, or Digraph)\*\*에서는 도로에 \*\*'방향'\*\*이 정해져 있습니다. A에서 B로 가는 일방통행 도로가 있다면, A에서는 B로 갈 수 있지만 B에서는 A로 돌아올 수 없습니다.

-----

### 방향 그래프의 기본 구성 요소

1.  **정점 (Vertex 또는 Node):** 지도의 '장소'나 '교차로'에 해당합니다. `1번 사람`, `2번 도시` 등이 정점이 될 수 있습니다.

2.  **간선 (Edge):** 정점과 정점을 잇는 '도로'입니다. 방향 그래프의 간선은 **화살표**로 표현하며, 시작점과 끝점이 명확하게 구분됩니다.

      * `A -> B`: A에서 B로 가는 간선이 있다는 의미입니다. A를 **꼬리(Tail)**, B를 \*\*머리(Head)\*\*라고 부르기도 합니다.

*(위 그림에서 1번 정점에서 2번 정점으로 갈 수 있지만, 2번에서 1번으로 직접 돌아갈 수는 없습니다.)*

### 무방향 그래프와의 핵심적인 차이점

방향이 생기면서 무방향 그래프에는 없는 중요한 개념 두 가지가 등장합니다.

  * **진입 차수 (In-degree):** **한 정점으로 들어오는 화살표(간선)의 개수**입니다.

      * 예시: `A -> C`, `B -> C` 라면, C의 진입 차수는 2입니다.
      * 의미: "얼마나 많은 정점이 나를 가리키는가?", "나에게 오기 위한 경로가 몇 개인가?"

  * **진출 차수 (Out-degree):** **한 정점에서 나가는 화살표(간선)의 개수**입니다.

      * 예시: `A -> B`, `A -> C` 라면, A의 진출 차수는 2입니다.
      * 의미: "내가 얼마나 많은 정점을 가리키는가?", "내가 갈 수 있는 경로가 몇 개인가?"

바로 직전에 풀었던 보증인 문제에서, `A -> B` (A가 B를 보증) 관계는 A의 진출 차수를 1 늘리고, B의 진입 차수를 1 늘리는 것과 같습니다.

### 코드로 표현하는 방법

방향 그래프를 코드로 표현하는 방법은 주로 두 가지입니다.

1.  **인접 행렬 (Adjacency Matrix):**

      * `N x N` 크기의 2차원 배열 `graph`를 만듭니다.
      * `A -> B` 간선이 존재하면 `graph[A][B] = 1`로 표시합니다.
      * **특징:** `graph[A][B]`가 1이라고 해서 `graph[B][A]`가 1인 것은 아닙니다. 이 비대칭성이 바로 '방향'을 표현합니다.

2.  **인접 리스트 (Adjacency List):** (코딩 테스트에서 가장 많이 사용)

      * 각 정점마다 리스트를 하나씩 가집니다.
      * `A -> B`, `A -> C` 간선이 존재하면, `list[A]`에 `B`와 `C`를 추가합니다.
      * **특징:** `list[A]`에 `B`가 있다고 해서 `list[B]`에 `A`가 있는 것은 아닙니다.

### 주요 알고리즘과 활용 분야

방향 그래프는 '순서'나 '의존 관계', '흐름'이 있는 모든 것을 모델링할 수 있습니다.

1.  **위상 정렬 (Topological Sort):**

      * **개념:** 방향 그래프의 정점들을 '순서에 맞게' 나열하는 것.
      * **예시:** 대학교의 선수과목 구조 (`자료구조`를 들어야 `알고리즘`을 들을 수 있다: `자료구조 -> 알고리즘`), 작업의 선후 관계 등.
      * 진입 차수가 0인 정점부터 처리하는 방식으로 동작합니다.

2.  **경로 탐색 (Pathfinding - DFS/BFS):**

      * **개념:** 한 정점에서 다른 정점으로 가는 경로가 존재하는지, 또는 최단 경로가 무엇인지 찾는 것.
      * **특징:** 탐색 시 간선의 방향으로만 이동할 수 있습니다.
      * **예시:** 바로 직전에 푸신 '보증인 찾기' 문제가 이 경우입니다. "P가 보증되었는가?"는 "P에서 trustedUser로 가는 경로가 있는가?"와 같은 질문이죠. (우리는 역방향 그래프를 만들어 반대로 탐색했습니다.)

3.  **웹 페이지와 링크:**

      * 웹 페이지를 정점, 하이퍼링크를 간선으로 보면 인터넷 전체가 거대한 방향 그래프가 됩니다. 구글의 페이지랭크 알고리즘이 바로 이 그래프를 분석하는 것입니다.

### 요약

| 특징 | 무방향 그래프 (양방향 도로) | **방향 그래프 (일방통행 도로)** |
| :--- | :--- | :--- |
| **간선** | 순서 없음 (A-B) | **순서 있음 (A -\> B)** |
| **차수(Degree)**| 그냥 '차수' 하나만 존재 | \*\*진입 차수(In-degree), 진출 차수(Out-degree)\*\*로 나뉨 |
| **표현** | `graph[A][B] = graph[B][A]` | `graph[A][B]`와 `graph[B][A]`가 다름 |
| **주요 응용** | 연결 관계, 네트워크 | **순서, 의존성, 흐름, 인과 관계** |

방향 그래프는 이 '방향성' 하나로 훨씬 더 풍부하고 복잡한 현실 세계의 관계들을 모델링할 수 있게 해주는 아주 강력한 도구입니다.