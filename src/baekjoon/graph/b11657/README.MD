백준 11657번 '타임머신' 문제는 최단 경로 문제 중에서도 아주 중요한 개념을 다루고 있습니다. 바로 **음수 가중치(Negative Weight)**가 있는 그래프에서의 최단 경로 탐색이죠.

이런 경우에는 다익스트라(Dijkstra) 알고리즘을 사용할 수 없습니다. 왜냐하면 다익스트라는 '가장 가까운 곳부터 방문한다'는 탐욕적인(Greedy) 접근법을 쓰는데, 음수 간선으로 인해 나중에 더 짧아지는 경로가 생기면 이 가정이 깨지기 때문입니다.

이 문제의 정해진 해결사는 바로 벨만-포드(Bellman-Ford) 알고리즘입니다.

1. 문제 분석 및 핵심 아이디어
목표: 1번 도시에서 출발하여 다른 모든 도시로 가는 가장 빠른 시간(최단 경로)을 구하는 것입니다.

그래프 특징:

방향 그래프(Directed Graph): 버스는 정해진 방향으로만 이동합니다.

음수 가중치(Negative Weight): 시간이 거꾸로 가는, 즉 음수인 간선이 존재할 수 있습니다.

가장 중요한 함정: 음수 사이클 (Negative Cycle)

음수 가중치 때문에 발생할 수 있는 특별한 상황입니다. 만약 어떤 경로를 따라 한 바퀴 돌았을 때 총시간이 음수가 된다면, 이 사이클을 무한히 돌면서 시간을 무한히 과거로 돌릴 수 있습니다.

이런 음수 사이클에 포함되거나, 그 사이클로부터 도달 가능한 도시에는 '최단 시간'이라는 개념이 성립하지 않습니다. (무한히 작아지므로)

따라서 우리는 최단 경로를 계산함과 동시에, 음수 사이클의 존재 여부도 감지해야 합니다.

2. 접근 방식: 벨만-포드 알고리즘
벨만-포드 알고리즘은 음수 가중치가 있는 그래프에서 최단 경로를 찾기 위해 고안되었습니다.

동작 원리: 다익스트라처럼 가장 가까운 정점을 선택하는 대신, 아주 간단하고 체계적인 방법을 사용합니다. 모든 간선에 대해 "완화(Relaxation)" 작업을 (정점의 수 - 1)번 반복합니다.

완화(Relaxation)란?
현재 알려진 도착점(v)까지의 최단 거리보다, 시작점(u)을 거쳐서 가는 경로(dist[u] + weight(u,v))가 더 짧다면, 도착점까지의 최단 거리를 갱신하는 작업을 의미합니다.

음수 사이클 감지:

최단 경로는 아무리 길어도 N-1개의 간선을 넘지 않습니다. (사이클이 없다면)

따라서 N-1번의 완화 작업을 마치면 모든 최단 거리가 결정되어야 합니다.

만약 N-1번 반복 후, 한 번 더(N번째) 완화 작업을 수행했을 때 또다시 거리가 갱신되는 정점이 있다면, 그 정점은 음수 사이클의 영향을 받는다는 것을 의미합니다.

3. 해결 과정 요약
초기화: 출발점(1번 도시)의 거리는 0으로, 나머지 모든 도시의 거리는 무한대(INF)로 초기화한 거리 배열 dist를 준비합니다.

간선 완화 반복: 총 N-1번, 그래프의 모든 간선을 하나씩 확인하며 완화 작업을 수행합니다.

음수 사이클 확인: 모든 간선을 한 번 더(N번째) 확인합니다. 이때 거리가 또 갱신된다면, 음수 사이클이 존재한다고 판단합니다.

결과 출력:

음수 사이클이 존재하여 N번째에도 갱신된 경로는 -1을 출력합니다.

거리가 여전히 무한대(INF)인 도시는 도달할 수 없는 곳이므로 -1을 출력합니다.

나머지 도시들은 계산된 최단 거리(dist 배열의 값)를 출력합니다.

# 출발 점이 도달 불가능 한 상태란

네, 그 부분은 벨만-포드 알고리즘의 핵심 원리를 담고 있는 아주 좋은 질문입니다!

결론부터 말씀드리면, 네, 알고리즘이 진행되는 동안에는 출발점이 '도달 불가능한 상태'일 수 있습니다.

여기서 말하는 '도달 불가능한 상태'는 도시 u가 지도에 존재하지 않는다는 뜻이 아니라, **"아직 출발 도시 1에서 도시 u까지 가는 유효한 경로를 발견하지 못했다"**는 의미입니다.

핵심 의미: 아직 신호가 닿지 않은 곳
if (dist[u] != INF) 조건은 '도시 u가 존재하는가?'가 아니라, **'출발 도시 1에서 도시 u까지 가는 경로를 우리가 이미 발견했는가?'**를 확인하는 것입니다. dist[u]가 INF(무한대)라는 것은 아직 1번 도시에서 u까지 닿는 방법(최단 시간)을 모른다는 뜻입니다.

알고리즘 진행 과정: 신호 퍼뜨리기 📶
벨만-포드 알고리즘의 동작을 'Wi-Fi 신호 퍼뜨리기'에 비유하면 쉽게 이해할 수 있습니다.

1. 시작 전 (초기화)
상황: 출발 도시 1에만 Wi-Fi 공유기가 설치되어 신호가 켜졌습니다.

코드: dist[1] = 0 으로 설정되고, 나머지 도시들은 신호가 닿지 않아 dist 값이 모두 INF입니다.

dist = [0, INF, INF, INF, ...]

2. 첫 번째 반복 (i=0)
상황: 알고리즘이 모든 버스 노선(간선) (u, v)를 하나씩 점검합니다.

if (dist[u] != INF)의 역할:

u가 1인 노선 (예: 1 -> 2)만 dist[1]이 0이므로 이 조건을 통과합니다.

u가 1이 아닌 노선 (예: 3 -> 4)은 아직 dist[3]이 INF이므로, 이 조건에 걸려 아무 계산도 하지 않습니다.

결과: 첫 번째 반복이 끝나면, 도시 1과 직접 연결된 이웃 도시들에만 처음으로 신호가 닿습니다. (예: dist[2], dist[3]이 INF가 아닌 값으로 바뀜) 다른 도시들은 여전히 INF 상태입니다.

3. 두 번째 반복 (i=1)
상황: 다시 모든 노선을 점검합니다.

if (dist[u] != INF)의 역할:

이제는 u가 1인 노선뿐만 아니라, 첫 번째 반복에서 신호가 닿았던 도시들 (예: u=2, u=3)에서 출발하는 노선들도 이 조건을 통과합니다.

비유하자면, 도시 2와 3이 신호를 받아 이제 'Wi-Fi 중계기' 역할을 시작하는 것입니다.

결과: 신호가 두 정거장 거리까지 퍼져나갑니다.

이 조건이 왜 필수적인가?
만약 이 조건이 없다면, 아직 신호가 닿지도 않은 먼 도시(예: dist[4] = INF)에서 출발하는 노선(4 -> 5)에 대해 dist[5] = dist[4] + cost와 같이 의미 없는 계산(INF + cost)을 시도하게 됩니다.

if (dist[u] != INF) 조건은 **"우리가 이미 경로를 아는 곳에서만 새로운 경로 탐색을 시작한다"**는 규칙을 만들어주어, 최단 경로가 출발지로부터 한 단계씩 질서정然하게 퍼져나가도록 보장하는 핵심적인 장치입니다.

# 왜 N-1만큼 반복 하나?

먼저 한 가지만 바로잡자면, 반복 횟수는 간선(M)의 개수가 아니라 정점(도시, N)의 개수와 관련이 있습니다. 정확히는 (정점의 개수 - 1), 즉 N-1번 반복하는 것이 핵심입니다.

왜 N-1번이면 충분한지, 그 이유를 단계별로 설명해 드릴게요.

## 핵심 원리: 최단 경로의 최대 길이
어떤 그래프에 시간을 무한히 되돌리는 '음수 사이클'이 없다고 가정해 봅시다.
이때, 1번 도시에서 다른 도시로 가는 최단 경로는 절대로 같은 도시를 두 번 방문하지 않습니다. 만약 같은 도시를 두 번 방문한다면,それは 빙 돌아가는 경로이므로 최단 경로가 될 수 없기 때문입니다.

총 도시가 N개이므로, 같은 도시를 두 번 방문하지 않는 경로는 최대 N개의 도시를 거치게 됩니다. 이는 곧, 최대 N-1개의 도로(간선)를 사용한다는 의미입니다.

예를 들어, 도시가 5개(N=5)일 때, 가장 긴 최단 경로는 1 -> 2 -> 3 -> 4 -> 5와 같이 5개의 도시를 모두 한 번씩 지나는 경로이며, 이때 사용된 간선은 4개(N-1)입니다.

결론 1: 음수 사이클이 없다면, 최단 경로는 최대 N-1개의 간선으로 이루어진다.

## 각 반복의 역할: 경로 길이 1씩 늘리기
벨만-포드 알고리즘의 for 루프는 한 번 반복될 때마다 최단 경로의 길이를 1씩 늘려나가는 것과 같습니다.

1번째 반복 후:
이 시점에는 1번 도시에서 간선 1개를 이용해 갈 수 있는 모든 최단 경로를 찾았음을 보장합니다. (1번 도시의 직접적인 이웃들의 dist 값이 갱신됩니다.)

2번째 반복 후:
1번째 반복에서 갱신된 이웃 도시들의 정보를 바탕으로, 이제 간선 2개 이하를 이용해 갈 수 있는 모든 최단 경로를 찾았음을 보장합니다.

예시: 1 --(비용5)--> 2 --(비용3)--> 3

1번째 반복에서 dist[2]가 5로 결정됩니다.

2번째 반복에서 dist[2]의 값을 이용해 dist[3]가 5 + 3 = 8로 결정됩니다. 즉, 간선 2개짜리 경로의 최단 거리는 2번째 반복에서 찾아집니다.

i번째 반복 후:
이런 식으로 i번째 반복이 끝나면, 간선 i개 이하를 사용하는 모든 최단 경로를 찾았음을 보장할 수 있습니다.

결론 2: i번 반복하면, 최대 i개의 간선을 사용하는 최단 경로를 찾을 수 있다.

## 종합 결론: N-1번이면 충분한 이유
위의 두 결론을 합쳐보면 답이 나옵니다.

최단 경로는 아무리 길어봤자 N-1개의 간선을 넘지 않습니다.

벨만-포드 알고리즘을 N-1번 반복하면, 최대 N-1개의 간선을 사용하는 모든 최단 경로를 찾을 수 있습니다.

따라서, N-1번을 반복하면, 이 그래프에 존재할 수 있는 모든 길이의 최단 경로를 계산하기에 충분한 것입니다. 이 이상 반복하는 것은 (음수 사이클이 없다면) 의미가 없습니다.

덤: N번째 반복의 의미
만약 N-1번을 반복해서 모든 최단 경로를 찾았는데도, N번째 반복에서 또 거리가 짧아진다면 무슨 의미일까요?
이는 N개 이상의 간선을 사용하는 경로가 더 짧다는 뜻입니다. N개의 간선을 사용하는 경로는 반드시 어딘가 도시를 중복 방문했다는 의미이며, 이는 바로 음수 사이클이 존재한다는 강력한 증거가 되는 것입니다. 이것이 벨만-포드 알고리즘이 음수 사이클을 감지하는 원리입니다.